# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class AbstractDownloadStrategy
  include ::FileUtils::StreamUtils_
end

class ActiveSupport::Deprecation
  def self.deprecation_warning(*args, &block); end

  def self.initialize(*args, &block); end

  def self.warn(*args, &block); end
end

module ActiveSupport::ForkTracker::CoreExtPrivate
  include ::ActiveSupport::ForkTracker::CoreExt
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  def abbrev(pattern=T.unsafe(nil)); end

  def fifth(); end

  def forty_two(); end

  def fourth(); end

  def from(position); end

  def second(); end

  def second_to_last(); end

  def shelljoin(); end

  def third(); end

  def third_to_last(); end

  def to(position); end

  def to_default_s(); end

  def to_h(); end
end

class Array
  def self.parse(string); end

  def self.try_convert(arg); end
end

class BasicObject
  def as_null_object(); end

  def null_object?(); end

  def received_message?(message, *args, &block); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not_receive(message, &block); end

  def should_receive(message, opts=T.unsafe(nil), &block); end

  def stub(message_or_hash, opts=T.unsafe(nil), &block); end

  def stub_chain(*chain, &blk); end

  def unstub(message); end
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def to_a(); end
end

module Benchmark
  def self.ms(&block); end
end

class BigDecimal
  def clone(); end

  def to_digits(); end
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

module Bootsnap::LoadPathCache
  DLEXT2 = ::T.let(nil, ::T.untyped)
end

class BottleSpecification
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module BuildEnvironment::DSL
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class BuildEnvironment
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end

  def global_path_appends_ruby_scope?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration::MoreFuture
  def backport_ext_builder_monitor(); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*arg); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*arg); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*arg); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Cask::AbstractCaskErrorWithToken
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Cask::Cache
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Cask::Cask
  def app(&block); end

  def artifact(&block); end

  def audio_unit_plugin(&block); end

  def binary(&block); end

  def colorpicker(&block); end

  def dictionary(&block); end

  def font(&block); end

  def input_method(&block); end

  def installer(&block); end

  def internet_plugin(&block); end

  def manpage(&block); end

  def mdimporter(&block); end

  def pkg(&block); end

  def postflight(&block); end

  def preflight(&block); end

  def prefpane(&block); end

  def qlplugin(&block); end

  def screen_saver(&block); end

  def service(&block); end

  def stage_only(&block); end

  def suite(&block); end

  def uninstall(&block); end

  def uninstall_postflight(&block); end

  def uninstall_preflight(&block); end

  def vst3_plugin(&block); end

  def vst_plugin(&block); end

  def zap(&block); end
end

class Cask::CaskQuarantineError
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Cask::CaskUnspecifiedError
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Cask::Cmd::AbstractCommand
  include ::Homebrew::Search::Extension
end

class Cask::Config
  def appdir(); end

  def appdir=(path); end

  def audio_unit_plugindir(); end

  def audio_unit_plugindir=(path); end

  def colorpickerdir(); end

  def colorpickerdir=(path); end

  def dictionarydir(); end

  def dictionarydir=(path); end

  def fontdir(); end

  def fontdir=(path); end

  def input_methoddir(); end

  def input_methoddir=(path); end

  def internet_plugindir(); end

  def internet_plugindir=(path); end

  def mdimporterdir(); end

  def mdimporterdir=(path); end

  def prefpanedir(); end

  def prefpanedir=(path); end

  def qlplugindir(); end

  def qlplugindir=(path); end

  def screen_saverdir(); end

  def screen_saverdir=(path); end

  def servicedir(); end

  def servicedir=(path); end

  def vst3_plugindir(); end

  def vst3_plugindir=(path); end

  def vst_plugindir(); end

  def vst_plugindir=(path); end
end

class Cask::DSL
  def app(*args); end

  def artifact(*args); end

  def audio_unit_plugin(*args); end

  def binary(*args); end

  def colorpicker(*args); end

  def dictionary(*args); end

  def font(*args); end

  def input_method(*args); end

  def installer(*args); end

  def internet_plugin(*args); end

  def manpage(*args); end

  def mdimporter(*args); end

  def on_arch_conditional(arm: T.unsafe(nil), intel: T.unsafe(nil)); end

  def on_arm(&block); end

  def on_big_sur(or_condition=T.unsafe(nil), &block); end

  def on_catalina(or_condition=T.unsafe(nil), &block); end

  def on_el_capitan(or_condition=T.unsafe(nil), &block); end

  def on_high_sierra(or_condition=T.unsafe(nil), &block); end

  def on_intel(&block); end

  def on_mojave(or_condition=T.unsafe(nil), &block); end

  def on_monterey(or_condition=T.unsafe(nil), &block); end

  def on_sierra(or_condition=T.unsafe(nil), &block); end

  def on_ventura(or_condition=T.unsafe(nil), &block); end

  def pkg(*args); end

  def postflight(&block); end

  def preflight(&block); end

  def prefpane(*args); end

  def qlplugin(*args); end

  def screen_saver(*args); end

  def service(*args); end

  def stage_only(*args); end

  def suite(*args); end

  def uninstall(*args); end

  def uninstall_postflight(&block); end

  def uninstall_preflight(&block); end

  def vst3_plugin(*args); end

  def vst_plugin(*args); end

  def zap(*args); end
end

class Cask::DSL::Caveats
  def depends_on_java(*args); end

  def discontinued(*args); end

  def files_in_usr_local(*args); end

  def free_license(*args); end

  def kext(*args); end

  def license(*args); end

  def logout(*args); end

  def path_environment_variable(*args); end

  def reboot(*args); end

  def requires_rosetta(*args); end

  def unsigned_accessibility(*args); end

  def zsh_path_helper(*args); end
end

class Cask::DSL::Container
  def nested(); end

  def nested=(nested); end

  def pairs(); end

  def pairs=(pairs); end

  def type(); end

  def type=(type); end
end

class Cask::DSL::Version
  def dots_to_hyphens(); end

  def dots_to_underscores(); end

  def hyphens_to_dots(); end

  def hyphens_to_underscores(); end

  def no_dots(); end

  def no_hyphens(); end

  def no_underscores(); end

  def underscores_to_dots(); end

  def underscores_to_hyphens(); end
end

class Cask::DSL::Version
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Cask::Denylist
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Cask::MultipleCaskErrors
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Caveats
  def empty?(*args, &block); end

  def to_s(*args, &block); end
end

class Checksum
  def [](*args, &block); end

  def empty?(*args, &block); end

  def length(*args, &block); end

  def to_s(*args, &block); end
end

class Class
  def any_instance(); end
end

class Cleaner
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class CompilerSelector::Compiler
  def self.[](*arg); end

  def self.members(); end
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_SYNCHRONOUS = ::T.let(nil, ::T.untyped)
end

module CopHelper
  def _investigate(cop, processed_source); end

  def autocorrect_source(source, file=T.unsafe(nil)); end

  def autocorrect_source_file(source); end

  def inspect_source(source, file=T.unsafe(nil)); end

  def parse_source(source, file=T.unsafe(nil)); end
end

module CopHelper
  extend ::RSpec::Core::SharedContext
  extend ::RSpec::Its
end

class Date
  def compare_without_coercion(arg); end

  def default_inspect(); end

  def minus_without_duration(arg); end

  def plus_without_duration(arg); end

  def to_default_s(); end
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Delegator
  include ::ActiveSupport::Tryable
end

class Dependencies
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Descriptions
  extend ::Homebrew::Search::Extension
end

class DevelopmentTools
  extend ::T::Private::Methods::SingletonMethodHooks
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

class DidYouMean::Formatter
  def message_for(corrections); end
end

class DidYouMean::Formatter
  def self.message_for(corrections); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::PatternKeyNameChecker
  def corrections(); end

  def initialize(no_matching_pattern_key_error); end
end

class DidYouMean::PatternKeyNameChecker
end

DidYouMean::PlainFormatter = DidYouMean::Formatter

class DidYouMean::RequirePathChecker
  def corrections(); end

  def initialize(exception); end

  def path(); end
end

class DidYouMean::RequirePathChecker
  def self.requireables(); end
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dictionary_without_leaves(); end

  def dimensions(); end

  def find_leaves(path); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def plausible_dimensions(input); end

  def possible_paths(states); end

  def separator(); end

  def tree_depth(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end

  def self.spell_checkers(); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.exists?(arg); end
end

class ELFTools::Structs::ELF32_PhdrBe
end

class ELFTools::Structs::ELF32_PhdrBe
end

class ELFTools::Structs::ELF32_PhdrLe
end

class ELFTools::Structs::ELF32_PhdrLe
end

class ELFTools::Structs::ELF32_symBe
end

class ELFTools::Structs::ELF32_symBe
end

class ELFTools::Structs::ELF32_symLe
end

class ELFTools::Structs::ELF32_symLe
end

class ELFTools::Structs::ELF64_PhdrBe
end

class ELFTools::Structs::ELF64_PhdrBe
end

class ELFTools::Structs::ELF64_PhdrLe
end

class ELFTools::Structs::ELF64_PhdrLe
end

class ELFTools::Structs::ELF64_symBe
end

class ELFTools::Structs::ELF64_symBe
end

class ELFTools::Structs::ELF64_symLe
end

class ELFTools::Structs::ELF64_symLe
end

class ELFTools::Structs::ELF_DynBe
end

class ELFTools::Structs::ELF_DynBe
end

class ELFTools::Structs::ELF_DynLe
end

class ELFTools::Structs::ELF_DynLe
end

class ELFTools::Structs::ELF_EhdrBe
end

class ELFTools::Structs::ELF_EhdrBe
end

class ELFTools::Structs::ELF_EhdrLe
end

class ELFTools::Structs::ELF_EhdrLe
end

class ELFTools::Structs::ELF_NhdrBe
end

class ELFTools::Structs::ELF_NhdrBe
end

class ELFTools::Structs::ELF_NhdrLe
end

class ELFTools::Structs::ELF_NhdrLe
end

class ELFTools::Structs::ELF_RelBe
end

class ELFTools::Structs::ELF_RelBe
end

class ELFTools::Structs::ELF_RelLe
end

class ELFTools::Structs::ELF_RelLe
end

class ELFTools::Structs::ELF_RelaBe
end

class ELFTools::Structs::ELF_RelaBe
end

class ELFTools::Structs::ELF_RelaLe
end

class ELFTools::Structs::ELF_RelaLe
end

class ELFTools::Structs::ELF_ShdrBe
end

class ELFTools::Structs::ELF_ShdrBe
end

class ELFTools::Structs::ELF_ShdrLe
end

class ELFTools::Structs::ELF_ShdrLe
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*arg); end
end

class Encoding::Converter
  def initialize(*arg); end
end

class Encoding
  def self._load(arg); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Enumerator
  def +(arg); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  def to_json(*args); end
end

class Exception
  def self.json_create(object); end
end

module Exception2MessageMapper
  def bind(cl); end
end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

class ExitCalledError
end

class ExitCalledError
end

class Fiber
  def transfer(*arg); end
end

class Fiber
  def self.current(); end
end

module Fiddle
  NULL = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class File
  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.exists?(arg); end

  def self.probe_stat_in(dir); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Formula
  include ::FileUtils::StreamUtils_
  def on_arch_conditional(arm: T.unsafe(nil), intel: T.unsafe(nil)); end

  def on_arm(&block); end

  def on_big_sur(or_condition=T.unsafe(nil), &block); end

  def on_catalina(or_condition=T.unsafe(nil), &block); end

  def on_el_capitan(or_condition=T.unsafe(nil), &block); end

  def on_high_sierra(or_condition=T.unsafe(nil), &block); end

  def on_intel(&block); end

  def on_linux(&block); end

  def on_macos(&block); end

  def on_mojave(or_condition=T.unsafe(nil), &block); end

  def on_monterey(or_condition=T.unsafe(nil), &block); end

  def on_sierra(or_condition=T.unsafe(nil), &block); end

  def on_system(linux, macos:, &block); end

  def on_ventura(or_condition=T.unsafe(nil), &block); end

  def uses_from_macos_names(*args, &block); end
end

class Formula
  def self.on_arch_conditional(arm: T.unsafe(nil), intel: T.unsafe(nil)); end

  def self.on_arm(&block); end

  def self.on_big_sur(or_condition=T.unsafe(nil), &block); end

  def self.on_catalina(or_condition=T.unsafe(nil), &block); end

  def self.on_el_capitan(or_condition=T.unsafe(nil), &block); end

  def self.on_high_sierra(or_condition=T.unsafe(nil), &block); end

  def self.on_intel(&block); end

  def self.on_linux(&block); end

  def self.on_mojave(or_condition=T.unsafe(nil), &block); end

  def self.on_monterey(or_condition=T.unsafe(nil), &block); end

  def self.on_sierra(or_condition=T.unsafe(nil), &block); end

  def self.on_system(linux, macos:, &block); end

  def self.on_ventura(or_condition=T.unsafe(nil), &block); end
end

module FormulaCellarChecks
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class FormulaConflict
  def self.[](*arg); end

  def self.members(); end
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*arg); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

class Gem::DependencyInstaller
  def _deprecated_add_found_dependencies(to_do, dependency_list); end

  def _deprecated_gather_dependencies(); end

  def add_found_dependencies(*args, &block); end

  def gather_dependencies(*args, &block); end
end

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  def self.redirector(); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::RemoteFetcher
  def correct_for_windows_path(path); end

  def s3_expiration(); end

  def sign_s3_url(uri, expiration=T.unsafe(nil)); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Resolver::ActivationRequest
  def others_possible?(); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

Gem::Resolver::DependencyConflict = Gem::Resolver::Conflict

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def to_ruby(); end
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.remove_spec(spec); end
end

class Gem::SpecificationPolicy
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.default_gems_use_full_paths?(); end

  def self.remove_unresolved_default_spec(spec); end
end

class HTTP::Cookie
  def self.parse(set_cookie, origin, options=T.unsafe(nil), &block); end
end

class Hardware::CPU
  def self.lm?(); end
end

module Hardware
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Hash
  def deep_transform_values(&block); end

  def deep_transform_values!(&block); end
end

module Homebrew
  MAX_PORT = ::T.let(nil, ::T.untyped)
  MIN_PORT = ::T.let(nil, ::T.untyped)
end

module Homebrew::API::Analytics
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Homebrew::API::Cask
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Homebrew::API::CaskSource
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Homebrew::API::Formula
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Homebrew::API::Versions
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Homebrew::CLI::Args
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Homebrew::EnvConfig
  def self.additional_google_analytics_id(); end

  def self.all_proxy(); end

  def self.arch(); end

  def self.artifact_domain(); end

  def self.auto_update_secs(); end

  def self.autoremove?(); end

  def self.bat?(); end

  def self.bat_config_path(); end

  def self.bat_theme(); end

  def self.bootsnap?(); end

  def self.bottle_domain(); end

  def self.brew_git_remote(); end

  def self.browser(); end

  def self.cache(); end

  def self.cleanup_max_age_days(); end

  def self.cleanup_periodic_full_days(); end

  def self.color?(); end

  def self.core_git_remote(); end

  def self.curl_retries(); end

  def self.curl_verbose?(); end

  def self.curlrc?(); end

  def self.debug?(); end

  def self.developer?(); end

  def self.disable_load_formula?(); end

  def self.display(); end

  def self.display_install_times?(); end

  def self.docker_registry_basic_auth_token(); end

  def self.docker_registry_token(); end

  def self.editor(); end

  def self.eval_all?(); end

  def self.fail_log_lines(); end

  def self.forbidden_licenses(); end

  def self.force_brewed_ca_certificates?(); end

  def self.force_brewed_curl?(); end

  def self.force_brewed_git?(); end

  def self.force_vendor_ruby?(); end

  def self.ftp_proxy(); end

  def self.git_email(); end

  def self.git_name(); end

  def self.git_path(); end

  def self.github_api_token(); end

  def self.github_packages_token(); end

  def self.github_packages_user(); end

  def self.http_proxy(); end

  def self.https_proxy(); end

  def self.install_badge(); end

  def self.install_from_api?(); end

  def self.livecheck_watchlist(); end

  def self.logs(); end

  def self.no_analytics?(); end

  def self.no_auto_update?(); end

  def self.no_bootsnap?(); end

  def self.no_cleanup_formulae(); end

  def self.no_color?(); end

  def self.no_compat?(); end

  def self.no_emoji?(); end

  def self.no_env_hints?(); end

  def self.no_github_api?(); end

  def self.no_insecure_redirect?(); end

  def self.no_install_cleanup?(); end

  def self.no_install_upgrade?(); end

  def self.no_installed_dependents_check?(); end

  def self.no_proxy(); end

  def self.pry?(); end

  def self.simulate_macos_on_linux?(); end

  def self.skip_or_later_bottles?(); end

  def self.sorbet_runtime?(); end

  def self.ssh_config_path(); end

  def self.sudo_askpass(); end

  def self.svn(); end

  def self.temp(); end

  def self.update_report_all_formulae?(); end

  def self.update_to_tag?(); end

  def self.verbose?(); end

  def self.verbose_using_dots?(); end
end

module Homebrew::Fetch
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Homebrew::FormulaCreator
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Homebrew::Livecheck::Strategy::ExtractPlist::Item
  def short_version(*args, &block); end

  def version(*args, &block); end
end

class Homebrew::Livecheck::Strategy::ExtractPlist::Item
  def self.[](*arg); end

  def self.members(); end
end

class Homebrew::Livecheck::Strategy::Sparkle::Item
  def nice_version(*args, &block); end

  def short_version(*args, &block); end

  def version(*args, &block); end
end

class Homebrew::Livecheck::Strategy::Sparkle::Item
  def self.[](*arg); end

  def self.members(); end
end

module Homebrew::Search
  include ::Homebrew::Search::Extension
end

class Homebrew::Service
  def bin(*args, &block); end

  def etc(*args, &block); end

  def libexec(*args, &block); end

  def opt_bin(*args, &block); end

  def opt_libexec(*args, &block); end

  def opt_pkgshare(*args, &block); end

  def opt_prefix(*args, &block); end

  def opt_sbin(*args, &block); end

  def var(*args, &block); end
end

module Homebrew
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  extend ::FileUtils::StreamUtils_
  extend ::Homebrew::Search::Extension
end

module HostEnvironmentSimulatorHelper
  def in_its_own_process_with(*files); end
end

module HostEnvironmentSimulatorHelper
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def getch(*arg); end

  def getpass(*arg); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(arg); end

  def pressed?(); end

  def raw(*arg); end

  def raw!(*arg); end

  def ready?(); end

  def wait(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end

  def winsize(); end

  def winsize=(winsize); end
end

class IO
  def self.console(*arg); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::Context
  def __exit__(*arg); end

  def __inspect__(); end

  def __to_s__(); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect_last_value(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*arg); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def initialize(file); end
end

class IRB::InputMethod
  def initialize(file=T.unsafe(nil)); end
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end
end

class IRB::Irb
  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

class IRB::Notifier::AbstractNotifier
  def initialize(prefix, base_notifier); end
end

class IRB::Notifier::LeveledNotifier
  def initialize(base, level, prefix); end
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::ReadlineInputMethod
  def initialize(); end
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def initialize(); end
end

class IRB::WorkSpace
  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end
end

module IRB
  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end
end

class Integer
  def to_bn(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end
end

class JSON::Ext::Parser
  def initialize(*arg); end
end

class KegOnlyReason
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Kernel
  include ::ActiveSupport::ForkTracker::CoreExtPrivate
  include ::ActiveSupport::ForkTracker::CoreExt
  def agree(*args, &block); end

  def ask(*args, &block); end

  def choose(*args, &block); end

  def pretty_inspect(); end

  def say(*args, &block); end
end

module Kernel
  def self.at_exit(); end

  def self.fork(); end

  def self.load(*arg); end

  def self.method_added(name); end
end

class KeyError
  include ::DidYouMean::Correctable
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module MachOShim
  def dylib_id(*args, &block); end

  def rpaths(*args, &block); end
end

class MessagePack::Packer
  def reset(); end

  def write_bin(arg); end

  def write_bin_header(arg); end
end

class MessagePack::Unpacker
  def feed_reference(arg); end

  def freeze?(); end
end

class Method
  include ::MethodSource::SourceLocation::MethodExtensions
  include ::MethodSource::MethodExtensions
end

MiniTest = Minitest

module Minitest::Assertions
  def assert_mock(mock); end
end

class Minitest::Expectation
  def ctx(); end

  def ctx=(_); end

  def target(); end

  def target=(_); end
end

class Minitest::Expectation
  def self.[](*arg); end

  def self.members(); end
end

module Minitest::Expectations
  def must_be(*args); end

  def must_be_close_to(*args); end

  def must_be_empty(*args); end

  def must_be_instance_of(*args); end

  def must_be_kind_of(*args); end

  def must_be_nil(*args); end

  def must_be_same_as(*args); end

  def must_be_silent(*args); end

  def must_be_within_delta(*args); end

  def must_be_within_epsilon(*args); end

  def must_equal(*args); end

  def must_include(*args); end

  def must_match(*args); end

  def must_output(*args); end

  def must_raise(*args); end

  def must_respond_to(*args); end

  def must_throw(*args); end

  def path_must_exist(*args); end

  def path_wont_exist(*args); end

  def wont_be(*args); end

  def wont_be_close_to(*args); end

  def wont_be_empty(*args); end

  def wont_be_instance_of(*args); end

  def wont_be_kind_of(*args); end

  def wont_be_nil(*args); end

  def wont_be_same_as(*args); end

  def wont_be_within_delta(*args); end

  def wont_be_within_epsilon(*args); end

  def wont_equal(*args); end

  def wont_include(*args); end

  def wont_match(*args); end

  def wont_respond_to(*args); end
end

module Minitest::Expectations
end

class Minitest::Mock
  def ===(*args, **kwargs, &b); end

  def __call(name, data); end

  def __respond_to?(*arg); end

  def class(*args, **kwargs, &b); end

  def expect(name, retval, args=T.unsafe(nil), **kwargs, &blk); end

  def initialize(delegator=T.unsafe(nil)); end

  def inspect(*args, **kwargs, &b); end

  def instance_eval(*args, **kwargs, &b); end

  def instance_variables(*args, **kwargs, &b); end

  def method_missing(sym, *args, **kwargs, &block); end

  def object_id(*args, **kwargs, &b); end

  def public_send(*args, **kwargs, &b); end

  def respond_to?(sym, include_private=T.unsafe(nil)); end

  def send(*args, **kwargs, &b); end

  def to_s(*args, **kwargs, &b); end

  def verify(); end
end

class Minitest::Mock
end

class Minitest::Spec
  include ::Minitest::Spec::DSL::InstanceMethods
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL
  def after(_type=T.unsafe(nil), &block); end

  def before(_type=T.unsafe(nil), &block); end

  def children(); end

  def create(name, desc); end

  def desc(); end

  def describe_stack(); end

  def it(desc=T.unsafe(nil), &block); end

  def let(name, &block); end

  def name(); end

  def nuke_test_methods!(); end

  def register_spec_type(*args, &block); end

  def spec_type(desc, *additional); end

  def specify(desc=T.unsafe(nil), &block); end

  def subject(&block); end

  def to_s(); end
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL::InstanceMethods
  def _(value=T.unsafe(nil), &block); end

  def before_setup(); end

  def expect(value=T.unsafe(nil), &block); end

  def value(value=T.unsafe(nil), &block); end
end

module Minitest::Spec::DSL::InstanceMethods
end

module Minitest::Spec::DSL
  def self.extended(obj); end
end

class Minitest::Spec
  extend ::Minitest::Spec::DSL
  def self.current(); end
end

class Mktemp
  include ::FileUtils::StreamUtils_
end

class MockExpectationError
end

class MockExpectationError
end

class Module
  def context(*a, &b); end

  def describe(*a, &b); end

  def example_group(*a, &b); end

  def fcontext(*a, &b); end

  def fdescribe(*a, &b); end

  def infect_an_assertion(meth, new_name, dont_flip=T.unsafe(nil)); end

  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end

  def xcontext(*a, &b); end

  def xdescribe(*a, &b); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

module NKF
  AUTO = ::T.let(nil, ::T.untyped)
  NOCONV = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
end

class Net::HTTP::Persistent
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  def to_d(); end
end

class Nokogiri::CSS::Parser
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class OS::Mac::BaseSDKLocator
  def initialize(*args, &blk); end
end

class OS::Mac::BaseSDKLocator
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class Object
  include ::Minitest::Expectations
  include ::Utils::Curl
  include ::SystemCommand::Mixin
  def __send(*arg); end

  def __send!(*arg); end

  def deep_dup(); end

  def duplicable?(); end

  def stub(name, val_or_callable, *block_args, **block_kwargs, &block); end

  def to_yaml(options=T.unsafe(nil)); end
  APPLY_A = ::T.let(nil, ::T.untyped)
  APPLY_B = ::T.let(nil, ::T.untyped)
  APPLY_C = ::T.let(nil, ::T.untyped)
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  BUG_REPORTS_URL = ::T.let(nil, ::T.untyped)
  COMMAND_DESC_WIDTH = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  DEPRECATED_OFFICIAL_TAPS = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  FORMULA_COMPONENT_PRECEDENCE_LIST = ::T.let(nil, ::T.untyped)
  HIDDEN_DESC_PLACEHOLDER = ::T.let(nil, ::T.untyped)
  HOMEBREW_BOTTLES_EXTNAME_REGEX = ::T.let(nil, ::T.untyped)
  HOMEBREW_BOTTLE_DEFAULT_DOMAIN = ::T.let(nil, ::T.untyped)
  HOMEBREW_BREWED_CURL_PATH = ::T.let(nil, ::T.untyped)
  HOMEBREW_BREW_DEFAULT_GIT_REMOTE = ::T.let(nil, ::T.untyped)
  HOMEBREW_BREW_FILE = ::T.let(nil, ::T.untyped)
  HOMEBREW_CACHE = ::T.let(nil, ::T.untyped)
  HOMEBREW_CACHE_FORMULA = ::T.let(nil, ::T.untyped)
  HOMEBREW_CASK_TAP_CASK_REGEX = ::T.let(nil, ::T.untyped)
  HOMEBREW_CELLAR = ::T.let(nil, ::T.untyped)
  HOMEBREW_CORE_DEFAULT_GIT_REMOTE = ::T.let(nil, ::T.untyped)
  HOMEBREW_DATA_PATH = ::T.let(nil, ::T.untyped)
  HOMEBREW_DEFAULT_CACHE = ::T.let(nil, ::T.untyped)
  HOMEBREW_DEFAULT_LOGS = ::T.let(nil, ::T.untyped)
  HOMEBREW_DEFAULT_PREFIX = ::T.let(nil, ::T.untyped)
  HOMEBREW_DEFAULT_REPOSITORY = ::T.let(nil, ::T.untyped)
  HOMEBREW_DEFAULT_TEMP = ::T.let(nil, ::T.untyped)
  HOMEBREW_GITHUB_PACKAGES_AUTH = ::T.let(nil, ::T.untyped)
  HOMEBREW_LIBRARY = ::T.let(nil, ::T.untyped)
  HOMEBREW_LIBRARY_PATH = ::T.let(nil, ::T.untyped)
  HOMEBREW_LINKED_KEGS = ::T.let(nil, ::T.untyped)
  HOMEBREW_LINUX_DEFAULT_PREFIX = ::T.let(nil, ::T.untyped)
  HOMEBREW_LINUX_DEFAULT_REPOSITORY = ::T.let(nil, ::T.untyped)
  HOMEBREW_LOCKS = ::T.let(nil, ::T.untyped)
  HOMEBREW_LOGS = ::T.let(nil, ::T.untyped)
  HOMEBREW_MACOS_ARM_DEFAULT_PREFIX = ::T.let(nil, ::T.untyped)
  HOMEBREW_MACOS_ARM_DEFAULT_REPOSITORY = ::T.let(nil, ::T.untyped)
  HOMEBREW_OFFICIAL_REPO_PREFIXES_REGEX = ::T.let(nil, ::T.untyped)
  HOMEBREW_PINNED_KEGS = ::T.let(nil, ::T.untyped)
  HOMEBREW_PREFIX = ::T.let(nil, ::T.untyped)
  HOMEBREW_PROCESSOR = ::T.let(nil, ::T.untyped)
  HOMEBREW_PRODUCT = ::T.let(nil, ::T.untyped)
  HOMEBREW_PULL_API_REGEX = ::T.let(nil, ::T.untyped)
  HOMEBREW_PULL_OR_COMMIT_URL_REGEX = ::T.let(nil, ::T.untyped)
  HOMEBREW_REPOSITORY = ::T.let(nil, ::T.untyped)
  HOMEBREW_REQUIRED_RUBY_VERSION = ::T.let(nil, ::T.untyped)
  HOMEBREW_RUBY_EXEC_ARGS = ::T.let(nil, ::T.untyped)
  HOMEBREW_SHIMS_PATH = ::T.let(nil, ::T.untyped)
  HOMEBREW_SYSTEM = ::T.let(nil, ::T.untyped)
  HOMEBREW_TAP_CASK_REGEX = ::T.let(nil, ::T.untyped)
  HOMEBREW_TAP_DIR_REGEX = ::T.let(nil, ::T.untyped)
  HOMEBREW_TAP_FORMULA_REGEX = ::T.let(nil, ::T.untyped)
  HOMEBREW_TAP_PATH_REGEX = ::T.let(nil, ::T.untyped)
  HOMEBREW_TEMP = ::T.let(nil, ::T.untyped)
  HOMEBREW_USER_AGENT_CURL = ::T.let(nil, ::T.untyped)
  HOMEBREW_USER_AGENT_FAKE_SAFARI = ::T.let(nil, ::T.untyped)
  HOMEBREW_USER_AGENT_RUBY = ::T.let(nil, ::T.untyped)
  HOMEBREW_VERSION = ::T.let(nil, ::T.untyped)
  HOMEBREW_WWW = ::T.let(nil, ::T.untyped)
  LINUXBREW_CORE_MIGRATION_LIST = ::T.let(nil, ::T.untyped)
  OFFICIAL_CASK_TAPS = ::T.let(nil, ::T.untyped)
  OFFICIAL_CMD_TAPS = ::T.let(nil, ::T.untyped)
  OPTION_DESC_WIDTH = ::T.let(nil, ::T.untyped)
  ORIGINAL_PATHS = ::T.let(nil, ::T.untyped)
  OS_VERSION = ::T.let(nil, ::T.untyped)
  PATCH_A_CONTENTS = ::T.let(nil, ::T.untyped)
  PATCH_A_SHA256 = ::T.let(nil, ::T.untyped)
  PATCH_B_CONTENTS = ::T.let(nil, ::T.untyped)
  PATCH_B_SHA256 = ::T.let(nil, ::T.untyped)
  PATCH_URL_A = ::T.let(nil, ::T.untyped)
  PATCH_URL_B = ::T.let(nil, ::T.untyped)
  RUBY18 = ::T.let(nil, ::T.untyped)
  RUBY19 = ::T.let(nil, ::T.untyped)
  RUBY_BIN = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PATH = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TESTBALL_PATCHES_SHA256 = ::T.let(nil, ::T.untyped)
  TESTBALL_PATCHES_URL = ::T.let(nil, ::T.untyped)
  TESTBALL_SHA256 = ::T.let(nil, ::T.untyped)
  TESTBALL_URL = ::T.let(nil, ::T.untyped)
  TEST_DIRECTORIES = ::T.let(nil, ::T.untyped)
  TEST_FIXTURE_DIR = ::T.let(nil, ::T.untyped)
  TEST_SHA1 = ::T.let(nil, ::T.untyped)
  TEST_SHA256 = ::T.let(nil, ::T.untyped)
  TEST_TMPDIR = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(arg); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*arg); end

  def self.pbkdf2_hmac(*arg); end

  def self.scrypt(*arg); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(arg); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class OpenURI::Buffer
  def <<(str); end

  def io(); end

  def size(); end
  StringMax = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
end

class OpenURI::HTTPError
  def initialize(message, io); end
end

class OpenURI::HTTPRedirect
  def initialize(message, io, uri); end
end

module OpenURI::Meta
  def content_type_parse(); end

  def meta_add_field(name, value); end

  def meta_add_field2(name, values); end

  def meta_setup_encoding(); end
  RE_LWS = ::T.let(nil, ::T.untyped)
  RE_PARAMETERS = ::T.let(nil, ::T.untyped)
  RE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  RE_TOKEN = ::T.let(nil, ::T.untyped)
end

module OpenURI::Meta
  def self.init(obj, src=T.unsafe(nil)); end
end

module OpenURI
  def self.check_options(options); end

  def self.open_http(buf, target, proxy, options); end

  def self.open_loop(uri, options); end

  def self.open_uri(name, *rest); end

  def self.redirectable?(uri1, uri2); end

  def self.scan_open_optional_arguments(*rest); end
end

class PATH
  def each(*args, &block); end
end

class PATH
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module ParallelTests
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Parlour::ConflictResolver
  extend ::T::Sig
end

class Parlour::Conversion::Converter
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class Parlour::Debugging::Tree
  extend ::T::Sig
end

module Parlour::Debugging
  extend ::T::Sig
end

class Parlour::Generator
  extend ::T::Sig
end

module Parlour::Mixin::Searchable
  extend ::T::Sig
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class Parlour::Options
  extend ::T::Sig
end

class Parlour::ParseError
  extend ::T::Sig
end

class Parlour::Plugin
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class Parlour::RbiGenerator::Parameter
  extend ::T::Sig
end

class Parlour::RbiGenerator::StructProp
  extend ::T::Sig
end

class Parlour::RbsGenerator::Block
  extend ::T::Sig
end

class Parlour::RbsGenerator::MethodSignature
  extend ::T::Sig
end

class Parlour::RbsGenerator::Parameter
  extend ::T::Sig
end

module Parlour::TypeLoader
  extend ::T::Sig
end

class Parlour::TypeParser::NodePath
  extend ::T::Sig
end

class Parlour::TypeParser
  extend ::T::Sig
end

class Parlour::TypedObject
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class Parlour::Types::Proc::Parameter
  extend ::T::Sig
end

class Parlour::Types::Type
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class Parser::Ruby26
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class PkgVersion
  def major(*args, &block); end

  def major_minor(*args, &block); end

  def major_minor_patch(*args, &block); end

  def minor(*args, &block); end

  def patch(*args, &block); end
end

class PourBottleCheck
  def on_arch_conditional(arm: T.unsafe(nil), intel: T.unsafe(nil)); end

  def on_arm(&block); end

  def on_big_sur(or_condition=T.unsafe(nil), &block); end

  def on_catalina(or_condition=T.unsafe(nil), &block); end

  def on_el_capitan(or_condition=T.unsafe(nil), &block); end

  def on_high_sierra(or_condition=T.unsafe(nil), &block); end

  def on_intel(&block); end

  def on_linux(&block); end

  def on_macos(&block); end

  def on_mojave(or_condition=T.unsafe(nil), &block); end

  def on_monterey(or_condition=T.unsafe(nil), &block); end

  def on_sierra(or_condition=T.unsafe(nil), &block); end

  def on_system(linux, macos:, &block); end

  def on_ventura(or_condition=T.unsafe(nil), &block); end
end

class Proc
  include ::MethodSource::SourceLocation::ProcExtensions
  include ::MethodSource::MethodExtensions
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

module Process
  def self.fork(); end
end

class Pry::BasicObject
  include ::ActiveSupport::ForkTracker::CoreExtPrivate
  include ::ActiveSupport::ForkTracker::CoreExt
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

class RBI::ASTVisitor
  extend ::T::Helpers
  extend ::T::Sig
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class RBI::File
  extend ::T::Sig
end

class RBI::Formatter
  extend ::T::Sig
end

class RBI::Index
  include ::T::Enumerable
end

module RBI::Indexable
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class RBI::Loc
  extend ::T::Sig
end

class RBI::Node
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class RBI::ParseError
  extend ::T::Sig
end

class RBI::Parser
  extend ::T::Sig
end

class RBI::Rewriters::Merge::Conflict
  extend ::T::Sig
end

class RBI::Rewriters::Merge
  extend ::T::Sig
end

class RBI::Rewriters::RemoveKnownDefinitions::Operation
  extend ::T::Sig
end

class RBI::UnexpectedParserError
  extend ::T::Sig
end

class RBI::Visitor
  extend ::T::Helpers
  extend ::T::Sig
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class REXML::XPathParser
  DEBUG = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  include ::RSpec::Matchers
end

module RSpec::Core::HashImitatable
  def assert_valid_keys(*args, &block); end

  def compact_blank(*args, &block); end

  def compact_blank!(*args, &block); end

  def deep_stringify_keys(*args, &block); end

  def deep_stringify_keys!(*args, &block); end

  def deep_symbolize_keys(*args, &block); end

  def deep_symbolize_keys!(*args, &block); end

  def deep_transform_keys(*args, &block); end

  def deep_transform_keys!(*args, &block); end

  def deep_transform_values(*args, &block); end

  def deep_transform_values!(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extractable_options?(*args, &block); end

  def including(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def many?(*args, &block); end

  def pick(*args, &block); end

  def pluck(*args, &block); end

  def stringify_keys(*args, &block); end

  def stringify_keys!(*args, &block); end

  def symbolize_keys(*args, &block); end

  def symbolize_keys!(*args, &block); end

  def to_options(*args, &block); end

  def to_options!(*args, &block); end

  def without(*args, &block); end
end

module RSpec::Core::MockingAdapters
end

module RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  def setup_mocks_for_rspec(); end

  def teardown_mocks_for_rspec(); end

  def verify_mocks_for_rspec(); end
end

module RSpec::Core::MockingAdapters::RSpec
  def self.configuration(); end

  def self.framework_name(); end
end

module RSpec::Core::MockingAdapters
end

class RSpec::Core::OutputWrapper
  def as_json(*args, &block); end

  def readline_nonblock(*args, &block); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
end

module RSpec::Matchers
  def a_json_string(*expected, &block_arg); end

  def a_string_containing(*args, &block); end

  def array_including_cons(*expected, &block_arg); end

  def be_a_failure(*args, &block); end

  def have_failed(*args, &block); end

  def not_raise_error(*args, &block); end

  def not_to_output(*args, &block); end
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Random
  def self.bytes(arg); end
end

class Range
  def %(arg); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  def self.completion_quote_character(); end
end

class ReporterHub
  def empty?(*args, &block); end
end

class Requirements
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class Resource
  include ::FileUtils::StreamUtils_
  def on_arch_conditional(arm: T.unsafe(nil), intel: T.unsafe(nil)); end

  def on_arm(&block); end

  def on_big_sur(or_condition=T.unsafe(nil), &block); end

  def on_catalina(or_condition=T.unsafe(nil), &block); end

  def on_el_capitan(or_condition=T.unsafe(nil), &block); end

  def on_high_sierra(or_condition=T.unsafe(nil), &block); end

  def on_intel(&block); end

  def on_linux(&block); end

  def on_macos(&block); end

  def on_mojave(or_condition=T.unsafe(nil), &block); end

  def on_monterey(or_condition=T.unsafe(nil), &block); end

  def on_sierra(or_condition=T.unsafe(nil), &block); end

  def on_system(linux, macos:, &block); end

  def on_ventura(or_condition=T.unsafe(nil), &block); end
end

class Resource::Partial
  def self.[](*arg); end

  def self.members(); end
end

class Ripper
  def column(); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*arg); end

  def lineno(); end

  def parse(); end

  def state(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def lex(); end

  def tokenize(); end
end

class Ripper::Lexer::Elem
  def event(); end

  def event=(_); end

  def initialize(pos, event, tok, state); end

  def pos(); end

  def pos=(_); end

  def state(); end

  def state=(_); end

  def tok(); end

  def tok=(_); end
end

class Ripper::Lexer::Elem
  def self.[](*arg); end

  def self.members(); end
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def to_int=(_); end

  def to_s=(_); end

  def |(i); end
end

class Ripper::Lexer::State
  def self.[](*arg); end

  def self.members(); end
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*arg); end
end

class Ripper
  def self.dedent_string(arg, arg1); end

  def self.lex_state_name(arg); end

  def self.token_match(src, pattern); end
end

module RuboCop::AST::CollectionNode
  def compact_blank(*args, &block); end

  def compact_blank!(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extract_options!(*args, &block); end

  def including(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def many?(*args, &block); end

  def pick(*args, &block); end

  def pluck(*args, &block); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_sentence(*args, &block); end

  def to_xml(*args, &block); end

  def without(*args, &block); end
end

class RuboCop::AST::Node
  def arch_variable?(param0=T.unsafe(nil)); end

  def block_args(param0=T.unsafe(nil)); end

  def block_body(param0=T.unsafe(nil)); end

  def cask_block?(param0=T.unsafe(nil)); end

  def key_node(param0=T.unsafe(nil)); end

  def method_node(param0=T.unsafe(nil)); end

  def val_node(param0=T.unsafe(nil)); end
end

class RuboCop::AST::NodePattern::Parser
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NodePattern::Sets
  SET_ARM_INTEL = ::T.let(nil, ::T.untyped)
  SET_BASH_COMPLETION_ZSH_COMPLETION_FISH_COMPLETION = ::T.let(nil, ::T.untyped)
  SET_BUILD_RECOMMENDED_TEST_OPTIONAL = ::T.let(nil, ::T.untyped)
  SET_DEPENDS_ON_USES_FROM_MACOS = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_WITH_WITHOUT = ::T.let(nil, ::T.untyped)
  SET_KEYS_VALUES_TO_H_TO_XML = ::T.let(nil, ::T.untyped)
  SET_ON_INTEL_ON_ARM = ::T.let(nil, ::T.untyped)
  SET_OR_NEWER_OR_OLDER = ::T.let(nil, ::T.untyped)
  SET_SYSTEM_SHELL_OUTPUT_PIPE_OUTPUT = ::T.let(nil, ::T.untyped)
  SET_TIME_DATETIME = ::T.let(nil, ::T.untyped)
  SET_WITH_WITHOUT = ::T.let(nil, ::T.untyped)
  SET____ETC_4 = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cask::AST::Stanza
  def app?(); end

  def appcast?(); end

  def arch?(); end

  def artifact?(); end

  def audio_unit_plugin?(); end

  def auto_updates?(); end

  def binary?(); end

  def caveats?(); end

  def colorpicker?(); end

  def conflicts_with?(); end

  def container?(); end

  def depends_on?(); end

  def desc?(); end

  def dictionary?(); end

  def font?(); end

  def homepage?(); end

  def input_method?(); end

  def installer?(); end

  def internet_plugin?(); end

  def language?(); end

  def livecheck?(); end

  def manpage?(); end

  def mdimporter?(); end

  def name?(); end

  def on_arch_conditional?(); end

  def pkg?(); end

  def postflight?(); end

  def preflight?(); end

  def prefpane?(); end

  def qlplugin?(); end

  def screen_saver?(); end

  def service?(); end

  def sha256?(); end

  def stage_only?(); end

  def suite?(); end

  def uninstall?(); end

  def uninstall_postflight?(); end

  def uninstall_preflight?(); end

  def url?(); end

  def version?(); end

  def vst3_plugin?(); end

  def vst_plugin?(); end

  def zap?(); end
end

class RuboCop::Cop::Cask::Variables
  def variable_assignment(param0); end
end

class RuboCop::Cop::Cop
  def highlights(); end

  def messages(); end
end

class RuboCop::Cop::FormulaAudit::ComponentsOrder
  def depends_on_node?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::FormulaAudit::DependencyOrder
  def build_with_dependency_node(param0); end

  def buildtime_dependency?(param0); end

  def dependency_name_node(param0); end

  def depends_on_node?(param0=T.unsafe(nil)); end

  def negate_normal_dependency?(param0); end

  def optional_dependency?(param0); end

  def recommended_dependency?(param0); end

  def test_dependency?(param0); end

  def uses_from_macos_node?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::FormulaAudit::DeprecateDisableDate
  def date(param0); end
end

class RuboCop::Cop::FormulaAudit::DeprecateDisableReason
  def reason(param0); end
end

class RuboCop::Cop::FormulaAudit::GenerateCompletionsDSL
  def correctable_shell_completion_node(param0); end

  def shell_completion_node(param0); end
end

class RuboCop::Cop::FormulaAudit::GitUrls
  def url_has_revision?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::FormulaAudit::Licenses
  def license_exception?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::FormulaAudit::Miscellaneous
  def conditional_dependencies(param0); end

  def destructure_hash(param0=T.unsafe(nil)); end

  def formula_path_strings(param0, param1); end

  def hash_dep(param0=T.unsafe(nil)); end

  def languageNodeModule?(param0); end
end

class RuboCop::Cop::FormulaAudit::OptionDeclarations
  def depends_on_build_with(param0); end
end

class RuboCop::Cop::FormulaAudit::Patches
  def patch_data?(param0); end
end

class RuboCop::Cop::FormulaAudit::Test
  def test_calls(param0); end
end

class RuboCop::Cop::FormulaAudit::Text
  def prefix_path(param0); end
end

class RuboCop::Cop::FormulaAuditStrict::GitUrls
  def url_has_tag?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::FormulaAuditStrict::Text
  def interpolated_share_path_starts_with(param0, param1); end

  def share_path_starts_with(param0, param1); end
end

class RuboCop::Cop::FormulaCop
  def dependency_name_hash_match?(param0, param1); end

  def dependency_type_hash_match?(param0, param1); end

  def required_dependency?(param0); end

  def required_dependency_name?(param0, param1); end
end

module RuboCop::Cop::OnSystemConditionalsHelper
  def if_arch_node_search(param0, arch:); end

  def if_base_os_node_search(param0, base_os:); end

  def if_macos_version_node_search(param0, os_version:); end

  def on_macos_version_method_call(param0=T.unsafe(nil), on_method:); end

  def on_system_method_call(param0=T.unsafe(nil)); end
end

module RuboCop::RSpec::ExpectOffense
  def expect_correction(correction, loop: T.unsafe(nil), source: T.unsafe(nil)); end

  def expect_no_corrections(); end

  def expect_no_offenses(source, file=T.unsafe(nil)); end

  def expect_offense(source, file=T.unsafe(nil), severity: T.unsafe(nil), chomp: T.unsafe(nil), **replacements); end

  def format_offense(source, **replacements); end

  def parse_annotations(source, raise_error: T.unsafe(nil), **replacements); end

  def parse_processed_source(source, file=T.unsafe(nil)); end

  def set_formatter_options(); end
end

class RuboCop::RSpec::ExpectOffense::AnnotatedSource
  def ==(other); end

  def annotations(); end

  def initialize(lines, annotations); end

  def lines(); end

  def match_annotations?(other); end

  def plain_source(); end

  def with_offense_annotations(offenses); end
  ABBREV = ::T.let(nil, ::T.untyped)
  ANNOTATION_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::RSpec::ExpectOffense::AnnotatedSource
  def self.parse(annotated_source); end
end

module RuboCop::RSpec::ExpectOffense
end

class RuboCop::RSpec::ParallelFormatter
  def dump_pending(*arg); end
end

class RuboCop::RSpec::ParallelFormatter
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class RubyVM::AbstractSyntaxTree::Node
  def pretty_print_children(q, names=T.unsafe(nil)); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*arg); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(arg); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module SharedEnvExtension
  def clang(); end

  def gcc(); end

  def llvm_clang(); end
end

module SharedEnvExtension
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SimpleCov::LinesClassifier
  NOT_RELEVANT = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class SoftwareSpec
  def on_arch_conditional(arm: T.unsafe(nil), intel: T.unsafe(nil)); end

  def on_arm(&block); end

  def on_big_sur(or_condition=T.unsafe(nil), &block); end

  def on_catalina(or_condition=T.unsafe(nil), &block); end

  def on_el_capitan(or_condition=T.unsafe(nil), &block); end

  def on_high_sierra(or_condition=T.unsafe(nil), &block); end

  def on_intel(&block); end

  def on_linux(&block); end

  def on_macos(&block); end

  def on_mojave(or_condition=T.unsafe(nil), &block); end

  def on_monterey(or_condition=T.unsafe(nil), &block); end

  def on_sierra(or_condition=T.unsafe(nil), &block); end

  def on_system(linux, macos:, &block); end

  def on_ventura(or_condition=T.unsafe(nil), &block); end
end

class Spoom::Cli::Bump
  extend ::T::Sig
end

module Spoom::Cli::Helper
  HIGHLIGHT_COLOR = ::T.let(nil, ::T.untyped)
end

module Spoom::Cli::Helper
  extend ::T::Sig
  extend ::T::Helpers
end

class Spoom::Cli::Main
  extend ::T::Sig
end

module Spoom::Colorize
  extend ::T::Sig
end

class Spoom::Coverage::D3::Base
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

module Spoom::Coverage::D3
  extend ::T::Sig
end

class Spoom::Coverage::Snapshot
  extend ::T::Sig
end

class Spoom::Coverage::Template
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

module Spoom::Coverage
  extend ::T::Sig
end

class Spoom::FileTree::Node
  extend ::T::Sig
end

class Spoom::FileTree
  extend ::T::Sig
end

module Spoom::Git
  extend ::T::Sig
end

class Spoom::LSP::Client
  extend ::T::Sig
end

class Spoom::LSP::Diagnostic
  extend ::T::Sig
end

class Spoom::LSP::DocumentSymbol
  extend ::T::Sig
end

class Spoom::LSP::Error::Diagnostics
  extend ::T::Sig
end

class Spoom::LSP::Hover
  extend ::T::Sig
end

class Spoom::LSP::Location
  extend ::T::Sig
end

class Spoom::LSP::Message
  extend ::T::Sig
end

class Spoom::LSP::Position
  extend ::T::Sig
end

module Spoom::LSP::PrintableSymbol
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class Spoom::LSP::Range
  extend ::T::Sig
end

class Spoom::LSP::ResponseError
  extend ::T::Sig
end

class Spoom::LSP::SignatureHelp
  extend ::T::Sig
end

class Spoom::Printer
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class Spoom::Sorbet::Config
  extend ::T::Sig
end

class Spoom::Sorbet::Errors::Error
  extend ::T::Sig
end

class Spoom::Sorbet::Errors::Parser
  extend ::T::Sig
end

module Spoom::Sorbet::Errors
  extend ::T::Sig
end

module Spoom::Sorbet::MetricsParser
  extend ::T::Sig
end

module Spoom::Sorbet::Sigils
  extend ::T::Sig
end

class Spoom::Timeline
  extend ::T::Sig
end

module Spoom
  extend ::T::Sig
end

module Stdenv
  def O0(); end

  def O1(); end
end

class String
  def exclude?(string); end

  def fast_xs(); end

  def indent(amount, indent_string=T.unsafe(nil), indent_empty_lines=T.unsafe(nil)); end

  def indent!(amount, indent_string=T.unsafe(nil), indent_empty_lines=T.unsafe(nil)); end

  def shellescape(); end

  def shellsplit(); end

  def to_nfc(); end

  def to_nfd(); end

  def to_nfkc(); end

  def to_nfkd(); end
end

class StringScanner
  def bol?(); end

  def initialize(*arg); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def filter(*arg); end
end

module Superenv
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Symbol
  def to_msgpack_ext(); end
end

module Tapioca
  extend ::T::Sig
end

class Tempfile
  def _close(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Time
  def compare_without_coercion(arg); end

  def eql_without_coercion(arg); end

  def minus_without_duration(arg); end

  def plus_without_duration(arg); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def to_default_s(); end
end

class Time
  def self.at_without_coercion(*arg); end
end

class TracePoint
  def __enable(arg, arg1); end

  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

module Tty
  def self.blue(); end

  def self.bold(); end

  def self.cyan(); end

  def self.default(); end

  def self.down(); end

  def self.erase_char(); end

  def self.erase_line(); end

  def self.green(); end

  def self.italic(); end

  def self.left(); end

  def self.magenta(); end

  def self.no_underline(); end

  def self.red(); end

  def self.reset(); end

  def self.right(); end

  def self.strikethrough(); end

  def self.underline(); end

  def self.up(); end

  def self.yellow(); end
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def buffer_open(buf, proxy, options); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::HTTP
  def buffer_open(buf, proxy, options); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end
end

class URITemplate::RFC6570::Expression::PathParameters
  PAIR_IF_EMPTY = ::T.let(nil, ::T.untyped)
end

module URL::BlockDSL::PageWithURL
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class URL::BlockDSL
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class URL::DSL
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class URL
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class UnboundMethod
  include ::MethodSource::SourceLocation::UnboundMethodExtensions
  include ::MethodSource::MethodExtensions
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class UnpackStrategy::Zip
  include ::UnpackStrategy::Zip::MacOSZipExtension
end

module UnpackStrategy
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class Utils::AST::FormulaAST
  def process(*args, &block); end
end

module Utils::Analytics
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Version::Parser
  def initialize(*args, &blk); end
end

class Version::Parser
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class Version::Token
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
end

class WeakRef
  def initialize(orig); end
end

class WebRobots
  def allowed?(url); end

  def crawl_delay(url); end

  def create_cache(); end

  def disallowed?(url); end

  def error(url); end

  def error!(url); end

  def flush_cache(); end

  def initialize(user_agent, options=T.unsafe(nil)); end

  def option(url, token); end

  def options(url); end

  def reset(url); end

  def sitemaps(url); end

  def user_agent(); end
end

class WebRobots::Error
end

class WebRobots::Error
end

class WebRobots::ParseError
  def initialize(message, site); end

  def site(); end
end

class WebRobots::ParseError
end

class WebRobots::RobotsTxt
  def allow?(request_uri, user_agent=T.unsafe(nil)); end

  def crawl_delay(user_agent=T.unsafe(nil)); end

  def error(); end

  def error!(); end

  def error=(error); end

  def initialize(site, records, options=T.unsafe(nil)); end

  def options(user_agent=T.unsafe(nil)); end

  def site(); end

  def sitemaps(); end

  def timestamp(); end
  DISALLOW_ALL = ::T.let(nil, ::T.untyped)
end

class WebRobots::RobotsTxt::AccessControlLine
  def match?(request_uri); end
end

class WebRobots::RobotsTxt::AccessControlLine
end

class WebRobots::RobotsTxt::AgentLine
  def pattern(); end
end

class WebRobots::RobotsTxt::AgentLine
end

class WebRobots::RobotsTxt::AllowLine
  def allow?(); end
end

class WebRobots::RobotsTxt::AllowLine
end

class WebRobots::RobotsTxt::CrawlDelayLine
  def delay(); end
end

class WebRobots::RobotsTxt::CrawlDelayLine
end

class WebRobots::RobotsTxt::DisallowLine
  def allow?(); end
end

class WebRobots::RobotsTxt::DisallowLine
end

class WebRobots::RobotsTxt::ExtentionLine
end

class WebRobots::RobotsTxt::ExtentionLine
end

class WebRobots::RobotsTxt::Line
  def compile(); end

  def initialize(token, value); end

  def token(); end

  def value(); end
end

class WebRobots::RobotsTxt::Line
end

class WebRobots::RobotsTxt::Parser
  def _reduce_1(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(target, crawl_delay_handler=T.unsafe(nil)); end

  def on_error(token_id, value, stack); end

  def parse(input, site); end

  def parse!(input, site); end

  def parse_error(message); end
  KNOWN_TOKENS = ::T.let(nil, ::T.untyped)
  RE_KNOWN_TOKENS = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class WebRobots::RobotsTxt::Parser
end

class WebRobots::RobotsTxt::Record
  def allow?(request_uri); end

  def default?(); end

  def delay(); end

  def initialize(agentlines, rulelines); end

  def match?(user_agent); end

  def options(); end
end

class WebRobots::RobotsTxt::Record
end

class WebRobots::RobotsTxt
  def self.unfetchable(site, reason, target=T.unsafe(nil)); end
end

class WebRobots
end

module Webrobots
  VERSION = ::T.let(nil, ::T.untyped)
end

module Webrobots
end

module YARDSorbet::Directives
  extend ::T::Sig
end

class YARDSorbet::Handlers::AbstractDSLHandler
  extend ::T::Sig
end

class YARDSorbet::Handlers::EnumsHandler
  extend ::T::Sig
end

class YARDSorbet::Handlers::IncludeHandler
  extend ::T::Sig
end

class YARDSorbet::Handlers::MixesInClassMethodsHandler
  extend ::T::Sig
end

class YARDSorbet::Handlers::SigHandler
  extend ::T::Sig
end

module YARDSorbet::Handlers::StructClassHandler
  extend ::T::Sig
end

class YARDSorbet::Handlers::StructPropHandler
  extend ::T::Sig
end

module YARDSorbet::NodeUtils
  extend ::T::Sig
end

module YARDSorbet::SigToYARD
  extend ::T::Sig
end

module YARDSorbet::TagUtils
  extend ::T::Sig
end

class Zlib::Deflate
  def initialize(*arg); end
end

class Zlib::GzipReader
  def initialize(*arg); end
end

class Zlib::GzipWriter
  def initialize(*arg); end
end

class Zlib::Inflate
  def initialize(*arg); end
end
